# Protein-tag Degree Of Labelling (ProDOL) analysis software

**Organization:** Herten Lab for Single Molecule Spectroscopy, University of Birmingham, UK  
**License:** GPLv3  
**Version:** 2023

Package providing a framework for Degree Of Labelling analysis usng ProDOL probe. The details of the analysis software and validation with experimental data are described in a bioRxiv preprint:

[to be submitted](to be submitted)

please cite this publication if you found this software useful.

## Dependencies

Although the package was tested with specific versions, other relatively new versions will likely work as well. If you have issues please get in touch. If you have issues with older ImageJ/MATLAB versions please consider updating.

- **MATLAB:**
	Tested with MATLAB 2021b
- **ImageJ:**
	Tested with ImageJ 1.54f
- **MATLAB/Image Processing Toolbox:**
	Tested with Version 11.1
- **MATLAB/Statistics and Machine Learning Toolbox:**
	Tested with Version 11.7
- **MATLAB/Parallel Computing Toolbox:**
	Tested with Version 7.2
- **MATLAB/Polyspace Bug Finder (optional):**
	Tested with Versio 3.2
- **ImageJ/ThunderSTORM:**
	Tested with 1.3-2014-11-08
	available from: https://github.com/zitmen/thunderstorm/releases

## Installation

The recommended way to use this software is cloning / downloading the git repository.

## Getting started
### ImageJ script
Open ImageJ and select `Plugins` -> `Marcos` -> `Run...`. Then navigate to the downloaded git repository and select `processAverageIJwiththunderSTORM.ijm`. 
Now input the relevant information into the GUI.
- `Reference Identifier` defines the unique string within the imagename to identifty the reference channel. E.g. `eGFP`
- `HaloTag Identifier` defines the unique string within the imagename to identifty the HaloTag channel. E.g. `HaloTag`
- `SNAPtag Identifier` defines the unique string within the imagename to identifty the SNAPtag channel. E.g. `SNAPtag`
- Define additional parameters such as `pixelwidth`, and camera parameters `gain`, `offset`, and `ADU per photon`

By clicking [OK], you then have to navigate to the root folder of the data to be analysed. The code then runs for several minutes to first convert the data into a consistent dataformat, average the imageStack, and run a single-molecule localisation algorithm on the images.

After completion a message box will pop-up stating that the script completed successfully. Each dataset folder should contain two new folders - `3Channels_Mask` and `ThunderSTORM_results`.


### MATLAB routine
Now open the `ProDOL_pipeline_thunderSTORM.m` script in MATLAB. Run the script and input the relevant information into the GUI.
- Define parameters such as `pixelwidth`, and Tag-dye names
- Select which Tags to be analysed from the drop-down menu: `HaloTag`, `SNAPtag`, or `Both Channels`
- Specify the root folder of this software, e.g. `C:\Users\username\Downloads\ProDOL-main`
- Specify the root folder of the image data, e.g. `E:\myData`
- Define additional parameters such as the folder names, these are generated by the `processAverageIJwiththunderSTORM.ijm` and should already be correct. Field implemented for backwards compatibility

Then press `Run ProDOL analysis`. A new output folder is created with all results.

### Structure of the input
The data to be analysed should be in a rootfolder which can have multiple subfolders for each condition. Within these subfolders must be the ".tif" files.

example tree structure:<br> 
rootFolder<br> 
&nbsp;&nbsp;&nbsp;|_condition1<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell01_eGFP.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell01_HaloTag.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell01_SNAPtag.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell02_eGFP.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell02_HaloTag.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell02_SNAPtag.tif<br> 
&nbsp;&nbsp;&nbsp;|_condition2<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell01_eGFP.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell01_HaloTag.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell01_SNAPtag.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell02_eGFP.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell02_HaloTag.tif<br> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|_cell02_SNAPtag.tif<br> 

tif files can have an arbitrary name, so long that each channel has a unique identifier, e.g. for the  reference: `eGFP`, `488nm`, or `Halo`

### Structure of the result
The imageJ-script generates two folder:
- 3Channels_Mask: in this folder the modified `.tif` files are saved with a consistent naming convention e.g. `cellXX_eGFP.tif` and a cell mask is created `cellXX_mask.tif`
- ThunderSTORM_results: in this folder the `image_list` analysed within ThunderSTORM is saved as well as the `.csv` file with all detected localisations.

The MATLAB routine generates one output folder with following files:
- `ColocThreshold_Tag.fig` showing the determined colocalisation threshold
- `DOL.fig` showing the results-plot of the determined DOL
- `DOL_Tag.txt` is a list of per `cell` DOL
- `LocAmplitude.fig` compares the distribution of points before and after filtering

## classes

### pointset class
#### properties

+ `name` name to indicate source of points (e.g. 'ts_multi eGFP fltr sigma', 'ts_multi SNAP fltr sigma', 'ground truth')
+ `(multichannelimage) parentImage` Image which this pointset belongs to
+ `sourceFile` original file where this pointset comes from (e.g.  thunderStorm csv-file)
+ `pointDetectionParameters` information about the origin of this point set (e.g. thunderStorm point detection parameters)
+ `points` points belonging to this set (parameter order in `pointsColumns`)
+ `pointsColumns` parameters of `points` array ('x', 'y', 'x rotated', 'y rotated', 'x registered', 'y registered', 'amplitude', 'sigma', 'offset')
+ `pointDensity` density of points (in um^-2^ ) within `parentImage.segmentedArea ` derived from mask channel of parent multicolorimage
+ `transformation` transformation matrix to a reference channel derived from channel registration
+ `pointFilteringParameters` structure array to store parameters for point filtering. Field `origin` references the original set, filtering was applied on.  Additional fields are created from the parameter and values filtering is performed on.

### multichannelimage class

#### properties

+ `channels` color channels of multicolor image (e.g. eGFP, bleached, Halo, SNAP, mask) with path of respective tif-file
+ `pixelSize` of tif files
+ `childPointSets` pointsets belonging to this image 
  That does not necessarily correspond to the channels, could be different point detection algorithms performed on one channel. Also filtering can create a new pointset containing less points
+ `parentImageSet`
+ `replicate` identifier to differ from other images in this imageset, usually the replicate
+ `segmentedArea` area derived from mask channel

### imageset class

+ `(multichannelimage) childImages`
+ `descriptors` variable number of unique parameters, defined as structure array with property-value pars. E.g. cell type, concentration, ... for cell screen; laser intensity, nd-filter for beads; dye combinations for dye screen; SNAP/Halo background for simulated data. On overview table of the imagesets and descriptors of an object (array) can be called with `imgSet.getAllDescriptors()`
+ `(dolan) results` array to store colocalisation analysis data, like DOL, multi-assignments, density, etc.  averaged over all images of this imageset.
+ `colocThreshold` max distance for colocalisation

### dolan class

This is a universal class for storing results of any calculation within the DOL analysis. In most cases it refers to a quantity that relates from one (or more) pointset to another (or others), that can be stored as objects in basePointSet and targetPointSet (that is not mandatory, e.g. for a mean transformation matrix stored with an imageset it is just defined as string referring to the names of the pointsets). You can link objects as `includedPoints`, `includedImages` or `includedImageSets` whenever helpful. 

#### properties

* `basePointSet` reference pointset
* `targetPointSet` sample pointset
* `variable` name of the variable e.g. 'DOL' or 'transformation'
* `value` 
* `uncertainty`
* `comment` (e.g. to define uncertainty as std/var or value as mean/median)
* `includedPoints` points that were included for calculation of that 
* `includedPoints`
* `includedImages` (if all points of both channels are included)
* `includedImageSets` (if all multichannelimages are included)

# DOLAN routine

## Data import

As datasets are heterogeneous import of data has to be designed for every experiment individually. Generally it should follow the following order (if applicable):

1. construct imageset
   An imageset represents a collection of multichannelimages with identical conditions. These conditions are stored in `imgset.descriptors` and should contain at least enough descriptors to uniquely distinguish it from other imagesets you are working on in parrallel.
2. add images
   create a multichannelimage object for every replicate in every imageset. Add a channel name (usually: 'eGFP', 'Halo', 'SNAP', 'mask', 'bleached', 'gray') and the path to the respective tif-file.
3. add pointsets by importing
   for every multichannelimage you can add any number of pointsets. Data formats and structures are different for sources of pointsets, so this has to be customized. Generally it is advisable to move through the DOLAN data structure (i.e. imagesets and multichannelimages) and to search for matches with the point sources.

## Visual Inspection for prescreening

dataSetInspector lets you browse through the dataset by displaying the 'eGFP' channel image and the segmentation. After visual inspection cells can be marked to be included or excluded for calculation of mean values in the set (e.g. DOL or density). The tool is called for a imageset with

```
dataSetInspector(imgset)
```

* You can use the keyboard to browse and classify. Keys are noted on the buttons.
* By ticking the checkbox 'random order' the 'next' and 'previous' buttons will browse to a (hidden) random order of the loaded samples.
* By ticking the checkbox 'unset only' images that have a classification are skipped. This will help if you resume an interrupted classification in random order
* If you encounter an error and the figure window cannot be closed focus the window and type `delete(gcf)` in the console

## Transformation (formerly known as registration)

Select a point set as a reference and align other pointsets to that reference. A full registration from all pointsets with name `targetName` to `baseName` can be performed by calling

```
imSet.fullTransformation('ts_multi eGFP fltr sigma', 'ts_multi Halo fltr sigma');
```

This calls the following methods consecutively:

```
imSet.calculateTransformation('ts_multi eGFP fltr sigma', 'ts_multi Halo fltr sigma');
```

- calculate transformation matrix for individual images
  - pointsets are filtered to contain only pairs with a single neighbor with a distance < 2px (This means that pointsets have to be prealigned)
  - transformation matrix is only calculated when >50 point pairs are available
  - transformation matrix is stored as pointset property `ptSet.transformation.T`
  - if calculated transformation uses large changes (translation > 20px, rotation > 5°, scaling > 1%) a warning is displayed

```
meanTHalo = imSet.calculateMeanTransformation('ts_multi eGFP fltr sigma', 'ts_multi Halo fltr sigma');
```

- calculate mean transformation (on imageset or imageset vector)

```
imSet.applyTransformation('ts_multi eGFP fltr sigma', 'ts_multi Halo fltr sigma');
```

- perform registration for all points
- pointsets with name `ts_multi eGFP fltr sigma` are set as reference. Their transformation matrix is set to unity and registeres positions of points are copied from original positions.

## Point filtering

### Filter by fixed value of point parameter

You can filter points by their properties 'sigma', 'amplitude' and 'background' using the pointset method filterpoints

```
ptSet.filterPoints(newName, pointParameter, filterValues, appendOrReplace)
```

It will create a new pointset with the name `newName` and copy the points matching the `filterValues` of `pointParameter`. This new pointset will be attached to the parent multichannelimage, you can toggle between appending the new pointset or replacing an existing pointset with identical name.

`filterValues` is a 2-element vector. If the second element is greater than (or equal to) the first, it means only points are accepted, that lie within these values. Otherwise points are accepted with values greater than the first or smaller than the second. 

Example 1:

```
ptSet.filterPoints('filtered', 'sigma', [0.7 2.7], 'replace');
```

will accept points with `0.7 < sigma < 2.7`, create a new pointset with the name 'filtered' and replace a pointset of the parent multichannelimage with the same name .

Example 2:

```
ptSet.filterPoints('filtered', 'aplitude', [1000 500], 'append');
```

will accept points with `amplitude > 1000` or `amplitude < 500` and append the new pointset to the parent multicolorimage

To perform filtering on all pointsets (with a certain name) on all multichannelimage of an imageset you can call the imageset method filterPointsByValue.

```
imSet.filterPointsByValue(targetName, newName, pointParameter, filterValues, appendOrReplace)
```

`targetName` is the name of the pointset to be filtered.

### Filter by percentage of reference imageset

The imageset method filterPointsByPercentile will determine the `filterValues` for `pointset.filterPoints()` by calculating the percentile of the point parameter for all points of a reference set. This could be an unstained cell.

```
imSet.filterPointsByPercentile(baseSet, targetName, newName, pointParameter, percentile, appendOrReplace)
```

will determine the `percentile` of `pointParameter` of all points in `baseSet` and filter all points in `imgset` to be higher than this threshold.

## DOL calculation

* call method colocalisation on imageset or multicolorimage with base and target pointset name. DOL is always calculated "in both ways" i.e. with respect to number of points of base and target pointset and added as result to both pointsets

```
imSet.colocalisation('ts_multi eGFP fltr sigma' , 'ts_multi SNAP fltr sigma', saveDir)
```

That consecutively performs the following steps:

```
imSet.calculateColocOverThresholds('ts_multi eGFP fltr sigma' , 'ts_multi SNAP fltr sigma');
```

* Calculate the degree of colocalisation between two pointsets over a distance threshold from 0.1 to 4 pixels with a step size of 0.1 px. Additionally multiple assigned points are stored and both (DOL and multi-assignments) are performed for one pointset rotated (Random). Results are stored as dolan objects with the respective multichannelimage. (varNames: 'DOL over threshold',  'multi-assignments over threshold', 'DOL-Random over threshold', 'multi-assignments-Random over threshold')

```
obj.findSignificantThreshold('ts_multi eGFP fltr sigma' , 'ts_multi SNAP fltr sigma');
```

* Find significant colocalisation distance threshold by comparing the degree of colocalisation with random control in dependence of the distance threshold. The significant threshold is stored with the imageset. Only pointsets with succesful registration are included assuming these are samples with a significant number of actually colocalizing points.

```
obj.setSignificantDOL('ts_multi eGFP fltr sigma' , 'ts_multi SNAP fltr sigma');
```

* Use the significant distance threshold and determine the DOL for every multichannelimage. Results are stored as dolan objects with the multichannelimage (varNames:  'DOL',  'multi-assignments', 'DOL-Random', 'multi-assignments-Random')

```
obj.calculateMeanColocalisation('ts_multi eGFP fltr sigma' , 'ts_multi SNAP fltr sigma');
```

* Calculate average DOL (and other quantities) over all images of an imageset at the significant distance threshold. Results are stored with the imageset as dolan objects (varNames: 'mean DOL', 'mean DOL Random', 'mean multi-assignments', 'mean multi-assignments Random')


## Density correction

The DOL can be corrected by the found density of points to compensate missed localisation due to psf-overlapping. The imageset method 
```
imSet.densityCorrection('ts_multi eGFP fltr sigma', 'ts_multi SNAP fltr sigma', offset, slope);
```
* will correct the DOL for all images in the included imageset(s). Input parameters are the name of base and
target pointset for whom the DOL will be corrected and offest and slope of the linear fit of the density correction derived from simulated data.

## Access DOL data

* For a single image: E.g. retrieve DOL from 'ts_multi eGFP fltr sigma' to 'ts_multi SNAP fltr sigma'

```
mci.results.dolanByVars('basePointSet', mci.pointSetByName(''ts_multi eGFP fltr sigma''), ...
	'targetPointSet', mci.pointSetByName('ts_multi SNAP fltr sigma'),...
	'varName', 'DOL');
```

Same thing works for multiple assigned points as well as DOL and multi-assignments for rotated image with their respective `varName`

* For one or more imagesets group dolans first, then use dolanByVars to extract the ones of interest. E.g. to plot the mean DOL with errorbars against the effective laser intensity for beads you can use:

```
allResults = [beadsImageSets.results];
dolDolans = allResults.dolanByVars('varName', 'mean DOL',...
    'basePointSet', 'ts_multi eGFP fltr sigma',...
    'targetPointSet', 'ts_multi SNAP fltr sigma');

% plot dol vs. effective laser intensity
for i = 1:length(dolDolans)
    Ieff(i) = dolDolans(i).includedImageSets.descriptors.effectiveIntensity;
    dol(i) = dolDolans(i).value;
    dol_std(i) = dolDolans(i).uncertainty;
end

errorbar(Ieff, dol, dol_std);
xlabel('effective intensity')
ylabel('DOL')
```

# Image Display

The method `showImage` displays a multicolorimage and overlays pointsets. Indicate a cell array to display the image channels (as defined in imageset creation, e.g. 'SNAP', 'Halo', 'eGFP', 'gray', 'mask') if available and a string or a cell array for pointsets to be displayed.

Example:

```
showImage(myImage, {'SNAP', 'eGFP', 'mask'}, {'ts_multi SNAP fltr sigma, 'ts_multi eGFP fltr sigma'})
```

displays the SNAPtag and eGFP image channel, the outline from the segmentation mask and overlays points from pointset 'ts_multi SNAP fltr sigma' and 'ts_multi eGFP fltr sigma'.

